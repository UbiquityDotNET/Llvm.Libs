<!--
One of the biggest problems with the native library is the MASSIVE size of the static libraries needed to build
the final dynamic library with support for ALL targets. Currently, it is not known how to make this plausible
on ANY OSS build infrastructure due to either time or storage space limitations (Or, usually, both).

To simplify the problem of building on a public OSS system like GitHub Actions this assumes the DLLs are built to
ONLY the native target AND one additional target. That will then enable the selection of the correct binary based
on the desired target, but will not allow for multiple target support beyond those two at any given time. (It
also means that the native library handle is loaded once for the lifetime of the process. That is the libray is
considered resolved on a per-function basis (like a delay load on Windows). The code will contain a resolver to
locate the correct module but that is ONLY used to resolve each function ONCE. Thus the library is not completely
released when the ILibLLvm is Disposed. [That is the implementation of that library does NOT OWN the native handle
and reloading a different target in the same process is not an option]

An alternative not implemented is to completely control the library load and P/Invokes using a COM like Vtable
where the handle and resolved function pointers are all owned by the ILibLLVM. Though that is a HUGE change to
the code base as it would need to "inject" such a dependency everywhere it is needed. Additionaly, the use of
LibraryImportAttribute generation is forfit with such an approach. A custom generator could be created to handle
this but that's a pretty significant undertaking of it's own. All in all that doesn't seem like a good long term
strategy.
-->
<Project Sdk="Microsoft.Build.NoTargets">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>

    <RuntimeIdentifier Condition="'$(RuntimeIdentifier)'==''">win-x64</RuntimeIdentifier>

    <!--
    To support metapacakge, this must use a NUSPEC file directly. The CSPROJ system
    for MSBUILD does NOT support creating such a thing directly.
    -->
    <NuSpecFile>LibLLVMRidMetaPackage.nuspec</NuSpecFile>

    <!-- Disable default inclusion of all items. This project doesn't use them -->
    <EnableDefaultItems>false</EnableDefaultItems>

    <!-- Disable default inclusion of analyzers. This project doesn't use them -->
    <EnableNETAnalyzers>false</EnableNETAnalyzers>
    <NoPackageAnalysis>true</NoPackageAnalysis>
    <NoCommonAnalyzers>true</NoCommonAnalyzers>

    <Authors>LLVM.org,Ubiquity.NET</Authors>
    <Description>Native Extendend Bindings of LLVM source for Ubiquity.NET.Llvm [$(LlvmVersion)]. Direct use of this low level API is **STRONGLY** discouraged (You are on your own!), instead you should use the Ubiquity.NET.Llvm package, which provides a full C# object model projection of the LLVM APIs on top of this library.</Description>
    <PackageTags>LLVM</PackageTags>
    <PackageProjectUrl>https://github.com/UbiquityDotNET/Llvm.NET</PackageProjectUrl>
    <RepositoryUrl>https://github.com/UbiquityDotNET/Llvm.NET.git</RepositoryUrl>
    <RepositoryType>git</RepositoryType>
    <PackageLicenseExpression>Apache-2.0 WITH LLVM-exception</PackageLicenseExpression>
    <PackageId>LibLLVM-$(RuntimeIdentifier)</PackageId>
  </PropertyGroup>

  <!-- Sanity/safety ensure NO referenced packages [Even if injected by Directory.Build.packages etc...] -->
  <ItemGroup>
    <PackageReference Remove="@(PackageReference)" />
  </ItemGroup>

  <ItemGroup>
    <None Include="LibLLVMRidMetaPackage.nuspec" />
  </ItemGroup>

  <!--
  Provide the standard properties for this project AND the source path of the generated files
  to the package generation so that the NUSPEC file will complete the pack. This project MUST
  use a NUSPEC file as the msbuild common project system does NOT provide any means to designate
  content files with a build action of "Compile" (The default oddly). It does it's own undocumented
  heuristics, apparently based on the package path. Ultimately there is no option to force source
  files to use a build action of compile, so a NUSPEC is required.
  -->
  <Target Name="SetNuspecProperties" BeforeTargets="GenerateNuspec">
    <PropertyGroup>
      <NuspecProperties>configuration=$(Configuration)</NuspecProperties>
      <NuspecProperties>$(NuspecProperties);packageID=$(PackageID)</NuspecProperties>
      <NuspecProperties>$(NuspecProperties);version=$(PackageVersion)</NuspecProperties>
      <NuspecProperties>$(NuspecProperties);authors=$(Authors)</NuspecProperties>
      <NuspecProperties>$(NuspecProperties);projectUrl=$(PackageProjectUrl)</NuspecProperties>
      <NuspecProperties>$(NuspecProperties);description=$(Description)</NuspecProperties>
      <NuspecProperties>$(NuspecProperties);tags=$(PackageTags)</NuspecProperties>
      <NuspecProperties>$(NuSpecProperties);licExpression=$(PackageLicenseExpression)</NuspecProperties>
      <NuspecProperties>$(NuSpecProperties);runtimeId=$(RuntimeIdentifier)</NuspecProperties>
    </PropertyGroup>
  </Target>
</Project>
